# 行为树(Behavior Tree)

对于用行为树定模型构造的AI系统来说，每次执行AI时 ，系统都会从根节点遍历整个树，父节点执行子节点，子节点执行完后将结果返回父节点，然后父节点根据子节点的结果来决定接下来怎么做。

## 类型节点(Node)

- **顺序节点(Sequence)** 属于组合节点，顺序执行子节点，只要碰到一个子节点返回false，则停止继续执行，并返回false，否则返回true，类似于程序中的逻辑与。
- **选择节点(Selector)** 属于组合节点，顺序执行子节点，只要碰到一个子节点返回true，则停止继续执行，并返回true，否则返回false，类似于程序中的逻辑或。
- **平行节点(Parallel Node)** 提供了平行的概念，无论子节点返回值是什么都会遍历所有子节点。所以不需要像Selector/Sequence那样预判哪个Child Node应摆前，哪个应摆后。Parallel Node增加方便性的同时，也增加实现和维护复杂度。
- **条件节点(Condition)** 属于叶子节点，判断条件是否成立。
- **执行节点(Action)** 属于叶子节点，执行动作，一般返回true。


## 有限状态机(FSM)

1. 平时的状态是巡逻
2. 如果遇到敌人之后打量一下敌人
3. 如果敌人比自己弱小，那就打攻击
4. 如果敌人比自己强大，那就跑逃跑

![FSM](/fsm.png "有限状态机")

带边框的节点表示状态，而箭头上的条件表示状态切换的条件。

虽然FSM简洁，和人的直觉思维相近，但是FSM也是有缺点的：
- 由于我们所能做的仅是编辑从一状态到另一状态的转换，而无法做出更高层次的模式功能，所以会导致我们发现自己总是在构建相似的行为，这会花费我们大部分时间。
- 使用 FSM 实现目标导向的行为需要做很多工作。这是一个大问题，因为大部分有针对性的AI 需要处理长远目标。
- FSM 难以并发。当并行运行多个状态机，要么死锁，要么我们通过手工编辑来确保它们在某个程度上能够兼容。
- 大规模支持较差，即使是分层的有限状态机，也难以大规模扩展。它们往往是在其中夹杂一大块逻辑代码，而非行为编辑模块化。
- 用 FSM 实现任何设计都需要做大量工作，需要花费设计师的大量时间(并非编程时间)，甚至最终这还会成行为中的 bugs 的来源。


文字来源 http://www.gameres.com/384827.html